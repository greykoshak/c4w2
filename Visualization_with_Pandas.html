<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Visualization_with_Pandas</title>
    <style type="text/css">
        body {
            font-family: verdana, arial, sans-serif;
        }
        b {
            font-size: 125%;
            color: blue;
        }
        i {
            font-size: 110%;
            color: green;
        }
    </style>
</head>
<body>

<div><p>
    В предыдущих видео мы научились работать с визуализацией данных в Python с помощью библиотеки matplotlib. На
    предыдущей мы также научились работать с данными с помощью библиотеки Pandas. В этом видео мы познакомимся с тем,
    как мы можем использовать библиотеку matplotlib для визуализации данных, хранящихся в наших Pandas датафреймах.
    Что ж, начнем. Мы будем использовать датасет titanic, который хранит информацию о пассажирах «Титаника», о их
    признаках и о факте того, выжили они в этой катастрофе или нет. Исследование любого датасета стоит начать с того,
    чтобы посмотреть какие-то свойства распределений тех или иных колонок. Начнем с того, что посмотрим, какие были
    стоимости у билетов и какое количество пассажиров владело какими билетами. Для этого берем наш датафрейм, берем поле
    <b>Fare</b>, в котором хранится информация о стоимости, и сейчас мы воспользуемся стандартным методом библиотеки
    Pandas — атрибутом <b>plot</b>. Атрибут plot есть у колонок и у всего датафрейма. И он содержит в себе набор
    методов, которые позволяют вызвать ту или иную визуализацию из арсенала библиотеки matplotlib. Например, мы хотим
    посмотреть гистограмму распределения. Просто вызываем <b>hist</b> и не забываем указать директиву <b>matplotlib
    inline</b>, для того чтобы наша визуализация была отражена внутри нашего Jupyter notebook. Запустим этот метод. Что
    мы видим? Мы видим гистограмму. Гистограмма берет наши данные, распределяет их по какому-то количеству интервалов
    значений и считает количество наблюдений, которые попали в тот или иной интервал. Мы видим, что больше всего
    наблюдений, или пассажиров, купили самые дешевые билеты. Мы можем детализировать наши представления, указав
    количество колонок, например, 20, или уменьшить детализацию, указав меньше колонок, например, пять. Мы также можем
    воспользоваться другими методами визуализации, например, построить плотностное распределение этого значения. Для
    этого вызовем у атрибута <i>plot</i> метод <b>kde</b> и увидим вот такой график. Что мы можем сделать дальше? Мы
    можем строить распределение не какой-то одной величины, а между разными величинами. Самое простое — это такой вид
    распределения, это <b>scatter plot</b>. Для этого нам нужно вызывать метод уже не у конкретной колонки, а у всего
    датафрейма. Мы работали в <i>df.plot</i> у всего датафрейма и вызываем метод <b>scatter</b>. Естественно, нам нужно
    принять какие-то два значения x и y. В виде x мы возьмем, например, все тот же Fare, а в виде y мы возьмем факт
    того, выжил пассажир или нет, атрибут <b>survived</b>. Мы видим два распределения, которые схожи между собой, но
    чуть отличаются. Мы видим, что как будто бы сверху в survived чуть больше людей с большей ценой билета, а внизу, в
    не survived, с чуть меньшей ценой. Давайте посмотрим, как еще мы можем визуализировать эти данные, чтобы подтвердить
    такое наше предположение или как-то его опровергнуть. Для этого давайте вспомним, что в Pandas есть метод
    <b>groupby</b>, который позволяет группировать данные по какому-то признаку, и построим два графика: для тех, кто
    survived и не survived. Для этого мы вызываем метод df.groupby и говорим, что хотим сгруппировать по факту
    выживания, survived. У всего этого мы получаем группы и говорим, что мы хотим взять Fare, и вызываем метод
    <b>plot.kde</b>, чтобы он нам нарисовал распределение наших данных. Видим два графика, которые чуть отличаются.
    Но а) непонятно, какой из них отвечает за survived, какой — нет; и б) слишком странный масштаб, есть минусовые
    значения. Давайте как-то это исправим. Для этого вспоминаем, что matplotlib поддерживает два метода работы с ним.
    Один — это процедурный, более простой; и второй — объектно-ориентированный. Воспользуемся процедурным. Для этого нам
    нужен теперь сам модуль matplotlib, импортируем его, как мы делали это прежде. import matplotlib.pyplot as plt.
    И после того как мы вызвали отрисовку нашего kde, мы говорим plt. Что мы хотим? Мы хотим видеть легенду. Потом
    говорим plt.legend и смотрим, что получилось. Вот, на графике, который нарисовал matplotlib из датафрейма, у нас
    появилась легенда, показывающая ноль — это синие, это не выжившие люди; 1, оранжевые — выжившие. Также давайте
    изменим наш диапазон значений по x. Скажем xlim, чтобы он начинался как минимум с нуля, а заканчивался, не учитывая
    весь огромный хвост, двумя сотнями. Что мы видим? Что распределение выживших чуть отклонено направо, то есть
    стоимость билетов у выживших людей была чуть выше, чем у тех, кто не выжил. И также тех, кто не выжил, в принципе
    было видимо было больше, они сконцентрированы в очень небольшом диапазоне, до 25 долларов. Что ж, отлично. Итак, мы
    работаем с Pandas датафреймами и визуализациями в процедурном режиме. Давайте посмотрим, как можно работать в
    объектном режиме. Во-первых, мы можем видеть, что если мы вызовем какой-либо из методов атрибута plot, например, все
    тот же Fare.plot.hist, видим, что он возвращает нам на самом деле уже объект Axes, с которым мы уже работали. Мы
    можем его сохранить в переменную ax и работать с ней так, как мы уже работали с объектами matplotlib. Например, мы
    скажем ax.set_title('Visualization'). И у нас появился заголовок у нашего графика. Это можно было делать и в
    процедурном стиле, но можно делать и таким образом. Также мы теперь можем сохранить изображение. Мы говорим
    ax.figure, и у этого figure вызываем метод savefig и указываем название файла. Например, something.png. Отлично.
    Что еще нам позволяет делать знание о том, что у нас есть объект ax? Оно позволяет нам нарисовать визуализации из
    Pandas уже какие-то другие холсты, которые могли были сделаны нами сами. Как мы это сделаем? Следующим образом.
    Мы берем и сами создаем наш figure и ax, как мы это делали прежде, указав метод subplot и указав размер нашего
    figure. И после этого мы делаем следующее. Мы когда вызываем у атрибута plot метод отрисовки чего-то, например, kde,
    говорим ему, на каком из Axes ему нужно рисовать. Чтобы он не рисовал где-то, где он сам решил, а мы указываем
    атрибут ax, который мы сами создали, и он на нем нарисует. И таким образом, мы можем рисовать множество графиков на
    одном и том же холсте, совмещая самые разные визуализации, как мы делали в предыдущем видео. Давайте посмотрим, что
    получится. Вот мы нарисовали множество графиков, а именно четыре, которые показывают, выжил человек или не выжил, и
    учитывают распределение по классам кабин. И мы видим, что куда выше вероятность выживания у оранжевого, то есть у
    первого класса, чем невыживания, а у третьего класса, самого низкого, куда выше вероятность невыживания, чем
    выживания. Таким образом, мы научились работать с визуализацией в Pandas датафреймов, используя библиотеку
    matplotlib. И вы понимаете, что это не просто вызов одной функции, которая что-то делает, а у вас есть полные
    возможности по настройке всего изображения, используя библиотеку matplotlib и встроенные в нее методы.
</p></div>
</body>
</html>